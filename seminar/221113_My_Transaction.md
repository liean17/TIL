# Rhinitis 트랜잭션 발표

## @Transational
본 발표는 트랜잭션이 무엇인지를 설명하는 것이 목적이 아닙니다.  
저희가 자주 쓰고있는, 또 자주 쓰게될 @Transactional을 사용함으로써 겪게될 수 있는 상황들을 공유하고자 합니다.  
먼저 이 발표에 지대한 영향을 주신 김영한님께 감사의 말씀을 올립니다.

### 선언적 트랜잭션 관리  
JPA, JDBC 등에 따라 트랜잭션 사용 방식이 조금씩 다릅니다.  
스프링은 이것을 commit rollback과 같이 추상화해서 제공합니다.  
앞서 말씀드린 @Transational은 선언적 트랜잭션 관리라고 합니다. 말그대로 선언만 해서 사용할 수 있는 방식입니다.  
그리고 트랜잭션 탬플릿이나 매니저를 가져와서 직접 사용하는 방식을 프로그래밍 방식 트랜잭션 관리라고 합니다.  
이 발표는 선언적 트랜잭션 관리에만 초점을 맞추겠습니다.  

---

### 프록시  
@Transactional AOP는 프록시 방식을 사용합니다.  
짧게 설명하면 실제 로직을 사용하지않고 가짜 로직으로 테스트를 해본 다음에 통과하면 commit하고 예외가 발생하면 rollback 하는 식 입니다.  
    - **상황 1프록시 내부 호출**  
    앞서 프록시 객체를 사용한다고 했는데 다음 같은 상황이 있습니다.  
    한 클래스에 A와 B라는 메서드가 있습니다.  
    A는 트랜잭션을 적용하지 않고 B 만 적용되어있습니다.  
    그런데 A메서드에서 B메서드를 호출한다고 합시다.  
    우선 B메서드만 호출하면 당연히 트랜잭션이 적용됩니다.  
    그리고 A메서드를 사용하면, 그 안에 B메서드도 트랜잭션 적용이될까요?  
    안됩니다. 이것은 자바의 호출 방식을 보면 알 수 있는데  
    자바는 모든 메서드를 실행할때 기본적으로 this를 생략합니다.  
    즉 트랜잭션이 적용된 상태에서 this는 프록시 객체를 의미하는데  
    그렇지 않은 메서드의 트랜잭션 메서드를 호출하면  
    트랜잭션이 적용된 프록시 객체가 아닌 this를 통한 실제 주소의 객체 인스턴스를 가져와서 트랜잭션 적용 없이 메서드를 호출하게 됩니다.  
        - 이를 해결하는 방법은 두가지 입니다.  
        첫번째는 컴파일 과정에서 트랜잭션을 알아서 적용하도록 AOP관련 코드를 수정하는 것 입니다. 이것은 매우 복잡하다고 합니다  
        두번째는 그냥 클래스를 분리하는 것 입니다.  
        트랜잭션을 적용하는 클래스를 따로 두면 외부 클래스의 메서드를 사용하는 것이되어 트랜잭션이 적용됩니다.  
    - **초기화 코드**  
    그리고 트랜잭션 AOP는 초기화 코드에 사용할 수 없습니다.  
    초기화 코드가 먼저 실행된 뒤에 트랜잭션 AOP가 적용되기 때문입니다.  
    이를 해결하기 위해서는 @EventListener를 사용해서 초기화가 끝나면 바로 실행하도록 설정하는 것입니다.  

### public  
트랜잭션은 public 메서드에만 적용되는것이 기본 설정입니다.  
클래스 레벨에서 트랜잭션을 적용하는 경우, 필요한 메서드에만 적용되기 위함입니다.  
여기 까지는 괜찮은데 이것을 생각하지않고 트랜잭션이 적용된 클래스에서 public이 아닌 메서드의 트랜잭션을 기대하는 경우, 예외가 발생하지않고 그냥 무시되기 때문에 신경써서 관리할 필요가 있습니다.

---

### 옵션들
@Transational의 몇가지 옵션들에 대해 소개해드리겠습니다.  
- **readOnly**  
말 그대로 읽기 전용입니다. 성능 최적화에 많은 도움이됩니다.  
그런데 드라이버나 데이터베이스에 따라 작동 방식이 다르고, 작동하지 않는 경우도 있다고 합니다.  
    - 예를들어 JdbcTemplate에서 읽기 전용인데 변경 기능을 시도하면 예외를 던집니다.  
    그리고 JPA는 읽기 전용은 커밋 시점에 플러시를 호출하지않고 스냅샷도 생성하지 않습니다.  

- **rollbackFor**  
트랜잭션은 기본적으로 언체크 예외인 RuntimeException과 그 하위 예외만 롤백을 수행합니다.  
즉 체크예외인 Exception과 그 하위 예외들이 발생하면 그냥 커밋합니다.  
    - 이런 정책을 사용하는 이유는 체크 예외는 예상 가능하고 발생시 큰 문제가 되지 않는 경우가 많기 때문입니다.  
    예를 들어 상품 결제시 고객의 돈이 부족해서 결제가 안되는 상황은 돈이 부족하다는것을 알리고 결제를 진행하지 않으면 되는거지 주문 전체과정을 롤백할 필요가 없습니다.  
    그러나 개발하면서 체크 예외라도 롤백이 필요할 수 있습니다. 이것을 지정해주는 옵션입니다.
    - 반대로 RuntimeException인데 굳이 롤백까지 할 필요는 없을 수도 있습니다.  
    noRollbackFor라는 옵션을 사용하면 됩니다.

- value = "transactionalManager"  
사용할 트랜잭션 매니저를 지정할 수 있습니다. 생략하면 기본으로 등록된 매니저를 사용합니다.  

- 다른 옵션들도 많은데 중요도가 낮다고 생각해서 생략하겠습니다.  
궁금하시면 강의를 구매하십시오 감사합니다.  

---  

## 트랜잭션 전파 커밋
- 트랜잭션이 겹칠때 커밋  
여러 클래스, 메서드를 사용하다보면  
트랜잭션을 사용하는 메서드 안에서 또 트랜잭션을 사용하는 메서드를 호출하는 경우가 있게됩니다.  
이 경우 어떻게 될까요? 트랜잭션이 두개 실행될까요?  
    - 밖에 있는 트랜잭션을 외부 트랜잭션, 그 안에서 실행되는 것을 내부 트랜잭션이라고 하겠습니다.  
    외부 트랜잭션이 실행되었을때 또 트랜잭션 메서드가 보이면, 내부 트랜잭션은 외부 트랜잭션에 '참여'합니다.  
    정확하게 말하면 내부 트랜잭션의 커밋 명령은 무시됩니다.  
    커밋을 하면 데이터베이스 커넥션이 종료되기 때문입니다.  

- 스프링은 이를 물리 트랜잭션, 논리 트랜잭션으로 구분합니다.  
위의 경우에는 외부 트랜잭션이 실제로 트랜잭션을 진행하는 물리 트랜잭션이 되고,  
트랜잭션이지만 실질적으로는 동작하지 않는 내부 트랜잭션이 논리 트랜잭션이 됩니다.

## 트랜잭션 전파 롤백  
롤백의 경우에는 어떨까요?  
일단 트랜잭션 대 전제를 말씀드리겠습니다.  
- 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋됩니다.
- 하나의 논리 트랜잭션이 롤백되어도 물리 트랜잭션은 롤백됩니다.  

- ### 1. 내부 트랜잭션은 커밋, 외부 트랜잭션이 롤백  
내부 트랜잭션이 모두 커밋되어서 외부 트랜잭션으로 왔는데, 외부 트랜잭션이 롤백되면 트랜잭션은 롤백됩니다.
- ### 2. 내부 트랜잭션이 롤백, 외부 트랜잭션은 커밋  
내부 트랜잭션이 롤백되었습니다. 그런데 앞서 말한것 처럼 내부 트랜잭션은 실질적으로 동작하지 않습니다. 이걸 어떻게 감지할까요?  
내부 트랜잭션에서 롤백이 감지되면, 트랜잭션 동기화 매니저로 'rollbackOnly'임을 표시합니다.  
물리 트랜잭션은 커밋 이전에 항상 rollbackOnly옵션을 검사하는데  
이것이 표시되었다면 전체 트랜잭션을 롤백하게 됩니다.  
이 경우 스프링은 'UnexpectedRollbackException'을 발생시킵니다.  

### 전파 옵션
- 트랜잭션을 별도로 두고싶을 수가 있습니다.  
이를 위한 여러가지 옵션이 존재합니다.  
설정방법
```java
DefaultTransactionAttribute definition = new DefaultTransactionAttribute();
definition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
TransactionStatus inner = txManager.getTransaction(definition);
```

- REQUIRED - 기본값  
기존 트랜잭션이 없으면 새로 생성하고, 있으면 참여합니다.  

- REQUIRED_NEW  
트랜잭션이 있건 없건 만듭니다

- SUPPORT  
트랜잭션이 없으면 안쓰고, 있으면 참여합니다

- NOT_SUPPROT  
있든 없든 그냥 안씁니다

- MANDATORY  
기존에 트랜잭션이 존재해야합니다. 없으면 예외를 발생시킵니다.  

- NEVER  
트랜잭션이 기존에 없어야합니다. 있으면 예외를 발생시킵니다.  

- NESTED  
기존 트랜잭션이 없으면 생성하고, 있으면 중첩 트랜잭션을 만듭니다.  
중첩 트랜잭션 : 외부 트랜잭션의 영향을 받지만, 외부에 영향을 주지는 않습니다.  
예를 들어 이 트랜잭션이 롤백되어도 전체 트랜잭션이 롤백되지는 않습니다.  
