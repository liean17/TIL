# 스프링을 앞둔 주말의 공부

## 보충공부

- DFS/BFS를 완전히 알고간다기 보다 템플릿을 익힐만큼이라도 조금 더 공부하자
- 스터디에서 주어진 문제를 위주로 공부한다
---
## DFS, BFS
 ---
### ***DFS***
    깊이 우선 탐색(Depth-First Search)
그래프에서 한 정점을 선택한 후 인접정접 하나를 끝까지(깊이까지) 탐색한다.  
Boolean배열을 사용해서 방문한 정점을 기록하고, 이후 재귀를 통해서 방문하지 않은 정점들을 마저 탐색한다.  
최단거리를 찾기 좋지만 목표가 바로 옆에 있어도 시간이 오래 걸릴 수 있다  

*dfs예시* 
```
public static void dfs(int start){
    //현재 방문한 정점을 체크한다
    visited[start]=true;

    //출력, 혹은 스택에 저장할 수도 있다.
    System.out.print(start+" ");

    for (int i = 1; i <= N ; i++) {
        //방문할 수 있고, 방문한 적 없는 정점인지 확인
        if (arr[start][i]==1&&visited[i]==false){
            //재귀를 통한 탐색
            dfs(i);
        }
    }
}
```

### ***BFS***
    너비 우선 탐색(Breadth-First Search)
재귀가 아닌 Queue를 사용한다. 한 정점을 선택해서 큐에 넣고 그 정점이 탐색할 수 있는 인근 정점을 모두 탐색하면서(Boolean배열로 방문여부를 체크한다) 큐에 저장한다  
방문할 수 있는 곳이 없으면 큐에서 정점을 하나씩 꺼내서 각 정점이 방문할 수 있는 곳을 체크한다  
이 작업은 Queue가 비어서 더이상 방문할 곳이 없을때 종료된다.

*bfs예시* 
```
public static void bfs(int start){
    //bfs는 큐를 사용한다
    Queue<Integer> queue = new LinkedList<>();
    //첫번째 정점 방문표시 + 큐에 저장
    visited[start]=true;
    queue.add(start);

    //큐에 저장된 것이 없으면 종료
    while (!queue.isEmpty()) {
        //큐에서 자료 꺼내오기
        int poll = queue.poll();
        //꺼내진 정점이 방문할 수 있는 곳을 큐에 저장하고, 방문을 체크한다.
        for (int i = 1; i <= N; i++) {
            if (arr[poll][i] == 1 && visited[i] == false) {
                queue.add(i);
                visited[i] = true;
            }
        }
    }
}
```

* 몰랐거나 고민했던 것

    1. 미로탐색 https://www.acmicpc.net/problem/2178  
    BFS의 대표적인 문제라고한다. 시작점에서 도착지점까지 가장 최단 거리를 계산하는 문제인데  
    어떤 방식으로 카운트해야하는지 잘 생각나지않는다.  

    2. 단어변환 https://programmers.co.kr/learn/courses/30/lessons/43163  
    처음 단어와 목표단어 그리고 앞 두 단어와 비슷하거나 같은 단어의 집단을 받아서  
    처음 단어가 목표 단어까지 변환하는데 소요되는 단계를 계산하는 문제이다.
* 풀이

    1. 미로탐색 : 방문한 칸 마다 방문하기까지의 칸 수를 기록  
    DFS와 좀 헷갈려서 최단거리를 한번에 찾아야 한다는 생각에 갇혀있었다.  
    하지만 BFS는 근처 칸 부터 하나씩 방문하기 때문에 일단 방문 가능한 칸을 모두 방문하는 것을 생각해야한다.  
    따라서 방문할 때 마다 방문하기까지의 칸 수를 기록하고 방문했다는 표시를 한다  
    그러다 목적지에 도착했을때 방문하기까지의 그 칸 수를 반환하면 된다. 

    2. 단어변환 : 스스로 풀진 못했지만 해결방법은 굉장히 심플한 문제였다.  
    어느 단어와 비교해서 변환할 수 있는 단어(한글자 빼고 같은 단어)인 경우 변환하고 방문을 표시한다  
    해당 작업을 반복하면 목표 단어에 도달하거나, 도달하지 못하게 된다
* 후기

    1. DFS를 내손으로 풀어서 좋아하긴했지만 그렇다고 더 나아가기엔 아직 익숙하지않다  
    꾸준히 접할필요가 있어보인다 물론 BFS도 마찬가지
    2. 앞으로 공부를 하고나서 그날 공부 난이도를 자체적으로 표기하자 생각이 들었다.  
    어려운것을 너무 오래 붙잡는것도 스트레스고 쉬운것을 계속하는것도 시간낭비다  
    어려운 것은 따로 표시를 해두고 시간날때마다 보도록 하자.
