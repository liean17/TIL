# Day 61

## 코드스테이츠

### 1. 학습시간 전
* 오늘 학습목표

    - 암호화와 hashing, salting 등의 개념을 이해할 수 있다.
    - HTTP와 HTTPS의 차이점을 이해할 수 있다.
    - 권한 부여(Authorization)와 인증(Authentication)에 대해 이해할 수 있다.
    - 쿠키의 작동 원리를 이해할 수 있다.
    - 클라이언트, 서버, 데이터베이스의 전체 동작을 이해할 수 있다.
    - 서비스의 보안과 관련된 방법을 알아보고 원리 및 장점 및 단점을 이해할 수 있다.

* 학습을 앞두고

    - 게임으로 치자면 최종장에 들어섰다. 사천왕을 물리치고 프로젝트라는 마왕을 물리쳐야 평화가 찾아온다  
    이전에 배운 지식들도 잊지않고 복습하면서 나아가자!  
    (사실은 마왕이 있을때가 행복한걸지도?)

* Daily Coding  
합병정렬 구현하기  
합병 정렬은 놀랍게도 폰 노이만이 제안한 방법이라고한다.  

```java
public class Solution {

    // 합치는 과정에서 사용되는 임시 배열
    private static int[] sorted;

    public int[] mergeSort(int[] arr) {
        sorted = new int[arr.length];
        merge_sort(arr,0,arr.length-1);
        return sorted;
    }

    public static void merge_sort(int[] arr, int left, int right){
        if (left==right) return;//길이가 1이면 반환

        int mid = (left+right)/2;//중간

        merge_sort(arr,left,mid);

        merge_sort(arr,mid+1,right);

        merge(arr,left,mid,right);

    }

    public static void merge(int[] arr, int left, int mid, int right){
        int L = left;//왼쪽 부분리스트의 시작
        int R = mid+1;//오른쪽 부분리스트의 시작
        int idx = left;//채워넣을 배열의 인덱스

        while (L<=mid && R<=right){
            //왼쪽 부분리스트의 L번째 원소가 오른쪽 부분리스트 R번째 원소보다 작거나 같으면
            //왼쪽 L번째 원소를 새로운 배열에 넣고 L과 idx를 증가시킨다.
            if(arr[L]<=arr[R]){
                sorted[idx] = arr[L];
                idx++;
                L++;
            }
            //왼쪽 부분리스트의 L번째 원소보다 오른쪽 부분리스트 R번째 원소가 작으면
            //오른쪽 R번째 원소를 새로운 배열에 넣고 R과 idx를 증가시킨다.
            else{
                sorted[idx] = arr[R];
                idx++;
                R++;
            }
        }
        // 왼쪽 부분 리스트가 다 채워졌으면,
        // 오른족 부분리스트의 나머지 원소들을 새 배열에 채워준다.
        if(L>mid){
            while (R<=right){
                sorted[idx] = arr[R];
                idx++;
                R++;
            }
        }
        // 오른쪽 부분 리스트가 다 채워졌으면,
        // 왼쪽 부분리스트의 나머지 원소들을 새 배열에 채워준다.
        else {
            while (L<=mid){
                sorted[idx] = arr[L];
                idx++;
                L++;
            }
        }
        // 정렬된 새 배열을 기존 배열에 옮겨준다.
        for (int i = 0; i <= right; i++) {
            arr[i] = sorted[i];
        }
    }
}

```  
* 풀이  
오름차순 정렬된 두 배열을 합쳐서(Merge)정렬한다면?  
각 배열의 맨 왼쪽부터 차례대로 비교하면 될 것이다.  
합병정렬은 이것에 더해서 배열을 계속 반으로 나눈다  
원소가 하나인 배열을 각각 비교하면서 합치면(Merge) 완성이다.

### 학습시간 이후
* 오늘의 난이도

    - 중
* 오늘의 정리
    - HTTP는 정보를 그대로 전송하기에 중간에서 정보를 확인하기 쉽다  
    HTTPS는 정보를 암호화해서 전송하기때문에 중간에 확인해더라도 암호키가 없다면 해석할 수 없다.  
    데이터 암호화의 방법으로는 대칭키방식/ 비대칭키 방식이 있는데 비대칭키 방식은 암호화할때와 해독할때의 키가 달라서  
    정보를 해석하기가 더욱 어려운 반면에 과정이 복잡하다는 단점이 존재한다  
    그렇기에 대칭키를 전송할때 비대칭키 방식으로 전송한 후 이후에는 대칭키 방식을 사용한다.  

    - CA  
    : 공인된 인증서를 발행한 제 3자
    서버는 클라이언트에게 사이트가 인증되었음을 알리는 인증서를 제공하고, 클라이언트는 CA리스트를 확인해서 인증서를 검증한다.  
    이때 인증서 내용이 리스트와 다르면 클라이언트가 기대하는 사이트가 아닐수도있음을 경고해준다.  

    - Hashing  
    : 어떠한 문자열에 '임의의 연산'을 적용해서 다른 문자열로 변환하는 것  
    해싱에는 3가지 원칙이 존재한다.   
        1. 해시값을 만드는데 오랜 시간이 걸리지 않을 것  
        2. 모두 고유한 해시값을 가질것  
        3. 작은 단위의 변경에도 크게 다른 해시값을 가질 것  

    - Salt   
    : 암호화해야하는 값에 '어떤 별도의 값'을 더해서 추가로 값을 변형하는 것  
    해싱에는 규칙이있기때문에 규칙만 파악하면 모든 암호를 풀수도 있을것이다  
    알고리즘으로 변형된 암호에 Salt라는 별도의 값을 더해 더욱 해독하기어려운 암호를 만드는 것이 Salting이다.  
    Salt역시 모두 같다면 쉽게 복호화할 수 있기때문에 몇가지 원칙이 존재한다.  
        1. 유저와 패스워드별로 다른 Salt값을 가져야한다
        2. 계정을 생성할때, 정보를 변경할때 마다 다른 Salt값을 생성해야한다
        3. Salt는 재사용되면 안된다.
        4. Salt는 DB에 함께 저장되어야한다.

    - Cookie  
    : 데이터를 클라이언트에 저장해서 Stateless한 HTTP를 Stateful하게 만들어준다.  
    항상, 모든곳에 쿠키가 사용되면 안되므로 여러 옵션이 존재한다. 

    - Session  
    : 사용자가 인증한 상태이며 이러한 정보를 유지해서 사용자 인증이 필요한 작업들을 간단하게 만들어준다.  
    세션 정보는 쿠키와 DB에 저장된다.

    ---
    - SQL Injection  
    : 항상 참인 문장을 요청해서 인증할때 해당 문장을 인식해서 인증에 통과하도록 만드는 해킹 기법  
    간단하고도 치명적이기 때문에 적극적인 방어가 필요하다.  
        1. 지정한 상황 외에는 모두 차단하는 화이트리스트 방법
        2. 사용자의 입력을 단순 텍스트로만 인식하도록 하는 PreparedStatement 방법
        3. SQL요청문이 외부에 드러나지않도록 에러메세지를 숨기는 방법

    - CSRF  
    : Cross-Site Request Forgery  
    특정 링크를 클릭하면 계좌에서 돈이빠져나가는 그 피싱수법이 CSRF방식이다.  
    해커가 설정한 정보를, 유저의 데이터를 사용해서 요청을 보내게 된다.  
    요청을 보내는 방식을 알고있어야 가능한 수법이므로 다음의 방어책이 유효하다.
        1. CSRF토큰을 유저의 브라우저와 웹 앱에만 제공해서 토큰 정보를 가진 요청만 받을 수 있도록한다.  
        2. Same-Site Cookie를 통해 같은 도메인에서 요청한 경우에만 쿠키/세션을 사용할 수 있도록 한다.

* 오늘 새롭게 배운 것

    - 보안이 철저한 웹사이트를 만들기 위해서는 역설적으로 해킹방법을 배워야한다.
    - 절대적으로 만능인 보안은 없으므로 항상 위험에 대비해야한다.

* 오늘의 질문

    - 보안이 뛰어날수록 성능은 줄어들게되는가?
* 총평  

    - 정말 오랜만에 가벼운 수업이었다.  
    아무래도 첫 수업이고 개념만 훑었기에 그렇겠지만 약간의 여유가있어서 좋다.  
    그만큼 스스로 공부를 잘하자.

---

## 개인공부  

### 오늘의 목표
- 클론코딩 강의 필요한 부분 듣기  
- 김영한님 강의 듣기  
- 알고리즘 책 읽고 정리
### 학습을 앞두고

- 남는 시간 활용이 중요하다! 시간이 많다고 욕심부리지 말고, 시간이 없다고 건너뛰어서는 안된다.  
그날 해야할 것을 충분히 생각하고 공부하자.

### 학습 이후
* 오늘의 난이도

    - 중
* 오늘의 정리

    - [트랜잭션](../../lecture/Spring_DB_1/2_Transaction.md)
    - [트랜잭션 AOP](../../lecture/Spring_DB_1/3_Transaction_AOP.md)

* 오늘 새롭게 배운 것

    - @Transaction과 AOP를 통한 트랜잭션을 아예 다른 별개의 방법으로 알고있었는데  
    어노테이션 방식의 원리가 AOP를 사용한다는 것을 알게되었다. 
    - 같은 깃 리포지토리의 문서에 접근하는 법을 배웠다.
* 오늘의 질문

    - @Transaction은 정확하게 어떻게 AOP를 통해 구현되는가?

* 총평 

    - 코드스테이츠에 들어가면서 중단했던 영한님 강의를 다시 들었다.  
    아마 코드스테이츠 수업을 듣지 않던때에 꾸준히 들었다면 지금처럼 쉽게 이해할 수 없었을 것 같다.  
    6개월짜리 부트캠프다보니 각 내용을 세부적으로 파고들기보다 사용법을 배우는 느낌이 강했다.  
    그래서 배울때마다 대체 어떤 원리도 동작하는지에 대한 의문들이 많았는데  
    트랜잭션의 경우 오늘에서야 보충이 되는 것 같다.  
    아마 이전 강의들도 다시보면 새롭게 보일것이다.  
    그래도 뭔가 공부해왔구나 하는 생각이 든다.  
    ***어렵고 잘 안되면 그냥 다시보고, 그래도 안되면 나중에 다시보면 된다.***
---