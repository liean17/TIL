# 리눅스 과제 정리
4주간 진행한 리눅스 과제를 정리한다.

### 나의 과제 수행 방법  
1. 주제를 검색해서 어디다 쓰는지, 어떻게 하는지를 찾는다.
2. 대부분 모르는 단어가 많기에 하나씩 파고들면서 과제를 이해한다.
3. 과제 방법에 대해서 어느정도 이해하고나면 직접 해본다.
4. 방법 위주로 ppt 정리를 하고 관련 핵심 기술, 개념에 대해 공부한다.

### 조언과 개선하면 좋을 것들
1. 주제와 관련된 개념, 단어를 모두 파고들어 조사해야한다.  
주제를 수행하는데 있어서 관련된 개념은 모두 알고있어야한다.  
과제 수행을 발표하는데 필요한 개념이 아니라, 주제를 설명하기 위해 등장하는 단어들에 대한 모든 개념
2. 처음부터 이해하고 해결해버리려하기보다도 과정을 찾아보고, 거기에서 나오는 모든 단어들에 대해 파해쳐야했다.  
한번에 이해하기 좋은 자료들을 찾다보니 오래걸렸고, 그 자료만으로 이해하기도 쉽지않아서 사용측면의 위주로만 조사한 것 같다.  
동작 원리에 대해서 상세하게, 거기에 쓰이는 개념들에 대해서도 상세하게
- 내가 원했던 것 : [모범자료](https://brunch.co.kr/@dreaminz/3)와 같은 친절한 자료의 존재
- 내가 해야했던 것 : 명령어 man페이지를 바탕으로 관련개념 싹다 정리,이해
---

## Week1 - 리눅스(우분투) 초기 설정
### 개요
보안 소프트웨어 엔지니어의 경우  
외부 인터넷이 연결되지 않은 상황에서 작업을 진행하는 경우가 대부분이다.  
리눅스 초기 설정과 함께 폐쇄망에서 작업을 하는 경우 필요한 설정에 대해 알아보자  

### 1. 파일 열기 개수 제한 해제
- **필요** : 리눅스는 디렉터리, 장치 등 모든 것이 파일이다.  
리눅스에는 최대 파일 오픈 개수가 설정되어있는데 해당 개수를 넘어서면 그 이상의 파일은 열리지 않는다. 즉 더 이상의 작업을 진행할 수 없다.  
따라서 최대 파일 열기 개수를 적절하게 수정함으로써 `too many open file` 오류를 방지해야한다.  

- **방법** : 
    - 오픈 파일 갯수 확인 `ulimit -a/ -Ha`
    - 시스템 전체 최대 오픈 파일 개수 확인 `cat /proc/sys/fs/file-max`  
    - 일시적인 방법 : ulimit -n/ -Hn [갯수] 로 변경 가능
    - 영구적인 방법 : `/etc/se2curity/limits.conf` 실행 후  
    <유저명> <soft/hard> <타입> <값> 형식으로 설정 후 저장 
    - 하지만 HardLimit의 경우에는 해당 명령으로는 1048576 이상으로는 설정 불가  
     - 커널의 최대 오픈 파일 수 변경  
    `/etc/sysctl.conf`에서 `fs.nr_open=5242880` 와 같이 설정하면(sysctl -p로 설정 반영) 

- 단어 설명
    - Soft Limit : 넘을 수도 있는, 경고 측면에서 사용 할 수 있는 제한
    - Hard Limit : 넘어서면 더이상 파일을 실행 시킬 수 없는 제한
    - `Too many open files` : 하드 리미트를 넘어선 파일 실행시 발생하는 메세지, var/log/messages에서 확인 가능하다.  

- 트러블 슈팅  
    - 분명 여러 자료에서는 ulimit -Hn으로 최대 오픈 파일 갯수를 수정할 수 있다고했다.  
    그런데 재원책임님이 말씀하신대로 기본적으로 설정된 갯수 이상으로는 변경할 수 없었다.  
    : 사실은 검색했을때 가장 첫번째로 나왔던 곳에서 최대 오픈 파일 갯수 제한을 해제하는 방법이 나와있었다. sysctl, 커널 등 관련 개념을 몰라서 가볍게 넘어갔던 탓이었다.  

### 2. 서버 타임존 설정
- **필요** : 리눅스를 설치하면 시간대가 UTC+0으로 설정되어있다.  
한국에서 사용하는 경우, 시간대가 한국으로 설정된 서비스와 작업을 진행할때 시간이 맞지않아 혼동이 생기거나 아예 서비스 자체가 동작하지 않을 수가 있다.  
따라서 작업하는 환경에 맞는 타임존을 설정해야한다.

- **방법** : 
    - 시간 상세 조회  
    : `timedatectl`
    - 타임존 확인  
    : `timedatectl list-timezones`
    - timedatectl을 사용한 설정 방법
    : `sudo timedatectl set-timezone Asia/Seoul`
    - 심볼릭 링크 방법  
    : `ls -l /etc/localtime`으로 확인 후 해당 파일 삭제 혹은 덮어쓰기  
    : 이후 새롭게 심볼릭 링크 파일을 생성 `sudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime`

- 단어 설명  
    - timedatectl : 시간 확인, 설정이 가능한 도구  
    기본적으로 현재 지역 시간, 협정 세계시간, 하드웨어의 시간, 타임존, 시스템 시간 동기화 여부, 타임서버 동기화 여부, 하드웨어 시간과 RTC를 동일하게 사용할 것인지에 대한 정보를 가진다.

### 3. NTP 서버 설정
- **필요** : Network Time Protocol  
앞선 타임존 설정과 마찬가지로 시간 설정은 리눅스 사용에서 매우 중요하다.  
여러 서버 장비를 사용하는 경우 장비간 시간이 동일해야하는데 NTP 서버를 동일하게 설정함으로써 네트워크를 통해 시간을 동일하게 설정할 수 있다.  

- **방법** :  
    - ntp 서비스 설치  
    : apt-get install -y ntp
    - /etc/ntp.conf 설정  
    : 기존 ntp설정을 삭제하고 설정하려는 ntp서버에 따라 값 입력  
    구글의 경우 : `server time1.google.com iburst`
    - ntp 재시작  
    `sudo service ntp reload`  
- 추가 사항  
1. NTP 서버는 일반적으로 외부 네트워크를 연결하게 된다.  
따라서 보안장비의 경우에는 함부로 외부 네트워크와 연결된 NTP 서버를 사용하기 쉽지않다.  
이에 대해서 현재 회사에서는 자체적으로 NTP 서버를 운영해서 폐쇄망의 경우에도 외부를 거치지 않고 시간을 설정할 수 있도록 하고있다고 한다.  
2. NTP서버를 연결할때 하나만 설정하지 않는다.  
구글의 경우에는 기본적으로 4개 서버를 설정할 수 있었는데 이를 통해서 동기화 중이던 서버가 고장이 나도 다른 서버에서 시간 데이터를 받아올 수 있기때문에 정확한 시간을 유지할 수 있다.  

### 4. systemd-networkd-wait-online.service 비활성
- **필요** : 위 서비스는 네트워크가 온라인 상태가 되기까지 기다리는 서비스 이다.  
네트워크 연결을 전제로 수행하는 작업의 경우에는 필요하지만 그렇지 않다면 기본 설정 시간인 120초간 다른 작업을 수행할 수 없게 된다.  
따라서 네트워크 연결이 필요없는 경우에는 비활성화 시키는 것이 좋다.  
- **방법** : `systemctl disable systemd-networkd-wait-online-service`  
- 추가 설명  
    - systemd-networkd-wait-online 서비스는 모든 링크가 구성되고나서 하나의 링크라도 인터넷이 연결되거나, 모두 실패할때 까지 기다리게 된다.  
    기본적으로 기다리는 시간은 120초로 설정되어 있다.  

### 5. 커널 자동 업데이트 비활성
- **필요** : 서비스 동작 중에 자동 업데이트가 진행되면 실행중이던 서비스는 갑자기 종료될 것이다.  
비활성화 시킴으로써 동작중인 서비스의 안정성을 가져올 수 있는데, 비활성화 함으로써 최신 업데이트를 반영하지 못하는 위험성 역시 존재하게 된다.  
따라서 자동 업데이트 비활성은 업데이트 시간을 사용자가 컨트롤 할 수 있다는 것에 의의가 있다.  
- **방법** :  
    - /etc/apt/apt.conf.d 의 10periodic, 20auto-upgrades 수정  
    ```
    # From
    APT::Periodic::Update-Package-Lists "1";
    APT::Periodic::Download-Upgradeable-Packages "0";
    APT::Periodic::AutocleanInterval "0";

    # To
    APT::Periodic::Update-Package-Lists "0";
    APT::Periodic::Download-Upgradeable-Packages "0";
    APT::Periodic::AutocleanInterval "0";
    APT::Periodic::Unattended-Upgrade "0";
    ```  
    혹은
    ```
    # From
    APT::Periodic::Update-Package-Lists "1";
    APT::Periodic::Unattended-Upgrade "1";

    # To
    APT::Periodic::Update-Package-Lists "0";
    APT::Periodic::Unattended-Upgrade "0";
    ```
    - 구성설정 파일을 순서대로 읽기 때문에 어느쪽에 설정해도 비활성화된다.  

### 로컬 리포지토리 구성  
- **필요** : 폐쇄망에서 패키지 설치, 업데이트를 할 수 있는 수단  
네트워크가 연결되어있지 않은 경우, 패키지를 설치하거나 업데이트를 할 수 있는 방법은 두가지가 있다. 하나는 USB나 CD와 같이 물리적인 저장장치를 연결하는 방법이 있고 두번째는 폐쇄망에만 네트워크를 따로 연결해서 필요한 파일을 제공하는 로컬 리포지토리를 구성하는 것이다.  
로컬 리포지토리 서버를 구성하는 것은 다음에 다루고 외부 저장장치를 마운트 하거나 리포지토리 서버를 연결해서 로컬 리포지토리를 설정하는 방법만 다룬다.
- **방법** :  
    - /etc/apt/source.list 에 리포지토리로 설정할 경로 지정  
    ex) add-apt-repository "deb file:/mnt/ubuntu/ local main"
- 추가 정보  
    - 외부 저장장치를 마운트하는 방법은 업데이트가 있을때마다 변경사항들을 일일히 반영해야한다.  
    따라서 외부 네트워크를 연결해서 파일을 미러링하는 서버를 구성하는 것이 좋다.

### 루트 계정 설정  
- **방법** : sudo passwd root

---

## Week2 - 리눅스 기타  

### 1. 리눅스의 종류  
리눅스는 다중 사용자와 멀티 태스킹에 적합한 운영체제인 UNIX를 본따 만든 운영체제로 오픈 소스라는 점이 특징이다. 따라서 수많은 사용자에 따라 다양한 종류가 탄생했고 그에 따른 차이가 존재한다.  

- 종류
    - 슬랙웨어 계열  
    배포판 중 가장 오래되었다는 것이 특징이다.  
    슬랙웨어는 패키지 매니저를 사용하지 않아서 사용자가 패키지 의존성 검사 등 모든 작업을 알아서 관리해야한다.  
    대표적인 슬랙웨어 계열의 운영체제는 SuSE가 있다.  
    SuSE는 독일에서 개발되어 유럽에서 많이 쓰이는 데스크탑/서버용 리눅스이다.  
    슬랙웨어에 패키지 매니저가 없다보니 zypper라는 패키지 매니저를 개발해서 사용한다.

    - 레드햇 계열  
    RedHat이라는 기업에서 제공하는 배포판이다. 대표적인 배포판으로는 RHEL이 있다. RHEL은 유료로 서비스를 제공하는데 소프트웨어에 대한 비용보다도 기술지원 측면의 비용이다.  
    그만큼 다른 배포판에 비해서 확실한 기술 지원을 받을 수 있다는 것이 특징이며 GPL(General Public License)에 따라 소스코드가 공개되어 있어서 RHEL을 그대로 따라 만든 CentOS라는 운영체제가 있다.  
    CentOS는 기업에서 안정적으로 운영하는 배포판을 무료로 사용할 수 있다는 특징이 있는데 RHEL의 변경사항에 대한 반영은 상대적으로 느릴 수 밖에 없고 기술 지원도 커뮤니티에 의존해야하다보니 RHEL보다는 안정적이지 못하다.  
    그 외에도 새로운 기술, 기능 업데이트 테스트에 사용되는 Fedora라는 운영체제가 있다.  

    - 데비안 계열  
    적극적으로 자유 소프트웨어를 추구하는 배포판이다.  
    기업이나 재단 등 적극적으로 배포를 추진하는 단체가 없고 안정성을 중시해서 다른 배포판들에 비해 업데이트 주기가 길다.  
    대표적인 파생 배포판으로는 우분투가 존재한다.
    우분투는 사용자 친화적인 사용법을 추구하기 때문에 초보자들에게 선호되는 운영체제가 되었다. 6개월에 한번씩 새로운 버전이 업데이트 되며 2년 주기로 최대 10년간 장기 지원을 보장하는 LTS 버전을 배포한다.  

- 대표적인 차이  
라이브러리, 설정 파일, 패키지 설치 방법과 관련해서 조금씩 차이가 있다.  
    - REHL계열은 yum 이라는 패키지 매니저를 사용하며  우분투는 apt라는 패키지 매니저를 사용한다.  
    대부분 동일한 기능을 제공하지만 사용법에서 조금씩 차이가 난다.  
    예를 들어 yum 에서 로컬 레포지토리를 구성하려면 .repo라는 파일을 생성해서 등록해줘야하는데 apt에ㅓ서는 sources.list 파일에 경로만 입력해주면 된다.  
또한 목적에 있어서도 추구하는 바가 다르다.  
RHEL을 사용하면 기업에서 제공하는 기술지원을 통해 본 업무에 집중할 수 있지만 안정적으로 운영할 수 있는 인적자원을 보유할 수 있는 기업은 CentOS나 우분투와 같은 대안을 고려할 수도 있다.  
그리고 해킹이나 디지털 포랜식 등 특정 기능에 특화된 리눅스 도 존재한다.   

### 2. 리소스 모니터링  
리소스 모니터링은 일반적으로 CPU, Memory, I/O, Network의 상태 변화를 지속적으로 감시하는 것을 말한다.  
CPU는 실질적인 작업을 처리하고, 메모리는 Cpu에서 처리할 데이터를 임시로 보관하며, 입출력 장치를 통해서 데이터를 보관하고 전송한다.  
리소스 모니터링은 컴퓨터에 사용되는 대표적인 장치들을 감시해서 장애를 확인하고 대비하는데 목적이 있다.  
- CPU 모니터링  
    - top, htop 명령어 사용
    - 주요 지표  
        - cpu% : cpu 사용 비율
        - load average : 수행되고 있거나 실행 가능한 상태, 혹은 입출력에 대기하고있는 상태에 있는 프로세스들의 개수를 1, 5, 15분 단위로 평균값을 낸 것  
            - 높다면 : 많은 프로세스가 실행 중이고, 실행 대기중이라는 것
            - 1분 값 < 15분 값 : 장애가 발생한지 시간이 조금 지났다
            - 1분 값 > 15분 값 : 현재 장애 발생중이다.  
            - 주의할 점 : 수행 되고 있는 프로세스와 응답 대기중인 프로세스 두가지를 함께 계산하고 있기 때문에 어느 프로세스의 비중이 큰지도 판단해야한다.  
                - vmstat 명령어에서 r,b 값을 확인하면 된다.
                    - r값이 높으면 CPU 리소스 부하
                    - b값이 높으면 입출력 부하
            - 참고 : [load average](https://brunch.co.kr/@dreaminz/1)
        - cpu 사용량 자체에 대한 모니터링보다도  
        다른 지표와 함께 정확한 원인 판단을 하는 것이 중요하다.
- Memory 모니터링  
    - free 명령어 사용[free](https://brunch.co.kr/@dreaminz/2)  
        - total : 전체 메모리
        - used : 사용중인 메모리
        - free : 사용되고 있지 않은 메모리
        - shared : 프로세스간 공유되고 있는 메모리(프로세스 혹은 스레드간 통신에서 사용)
        - buff/cache : 버퍼,캐시에 사용되고 있는 메모리
            - 캐시 : 빠른 실행을 위해서 '파일의 내용'을 미리 저장해 둔 것. 
            - 버퍼 : 미리 '파일에 대한 정보'를 저장해 둔 것
        - available : 사용되고 있지 않은 메모리(free)에 사용 중이지만 활용 가능한 메모리(buff/cache 등)를 더한 실제로 사용 가능한 메모리
            - 즉 free가 부족해도 available에 여유가 있다면 당장 메모리 부족을 걱정할 필요는 없다.
            - 메모리가 부족하면 자동으로 buff/cache를 정리하지만 직접 정리하는 방법도 있으며 최소 free 메모리를 설정하는 방법도 있다.
                - 직접 정리  
                : `echo [number] >> /proc/sys/cm/drop_caches`  
                [number]에는 비우기 단계를 설정한다.  
                    1. Page cache 비우기
                    2. dentry(inode와 관련해서 파일에 빠르게 접근할 수 있도록 돕는 데이터),Inode비우기
                    3. 모두 비우기
                - 최소 free 메모리 설정  
                `sysctl -w vm.min free kbytes=[value]`  
                설정한 최소 메모리 이하로 떨어지지 않게 buff/cache 메모리를 알아서 정리한다.
        - swap : 디스크에서 메모리로 활용하고 있는 공간  
            - 상대적으로 느린 디스크를 활용하는 만큼 메모리에 비해 많은 성능 저하를 보인다.  
            - /proc/<PID>/smaps 파일을 확인해서 프로세스별 메모리 영역 주소, swap크기를 확인할 수 있으며 이것이 번거롭다면 smem 툴을 사용해서 swap사용 현황을 파악할 수 있다.  
    - 메모리가 부족한 경우 캐시/버퍼 공간을 반환한다.  
    반환 이후에도 공간이 부족한 경우에는 swap을 사용하게 되는데 swap마저 어려운 경우에는 OOM(Out of Memory) Killer에 의해 프로세스를 강제 종료 시킨다. 
- 입출력 모니터링
- 네트워크 모니터링  
    - ifconfig 명령어 사용

- 추가 정리
    - 메모리 단편화 : 메모리의 공간이 작게 쪼개져서, 총 공간은 여유가 있지만 사용이 불가능한 상태
        - 내부 단편화 : 메모리 할당시 프로세스가 필요한 양보다 더 많은 메모리가 할당되어 그 차이만큼 발생한 단편화
        - 외부 단편화 : 메모리 할당/해제 과정에서 발생한 단편화(예를 들어 총 공간이 30인 상황에서 8을 사용하는 프로세스에 이어 16을 사용하는 프로세스가 실행되었다. 그리고 8이 종료되면 14의 공간이 사용가능하지만 앞에서 8/ 뒤에서 6의 공간이 남아 9 이상은 사용이 불가능한것)
        - 해결 방법
            1. Paging - 리눅스에서 사용중인 방법  
            공간을 동일한 크기로 분리해서 메모리를 분할하여 할당하는 방법.  
            프로세스 메모리를 연속적으로 배치하지 않아서 외부 단편화가 발생하지 않는다.  
                - 리눅스 커널은 `buddy system`을 사용해서 메모리를 할당한다.  
                메모리를 2^n으로 각각 할당해서 프로세스에서 필요한 만큼 연속된 페이지를 제공하는 방식이다.

            2. Segmentation - 프로세스를 code, data, stack등 영역별로 나눈 세그먼트를 기준으로 분할해서 할당하는 방법. 페이징과 다르게 나뉘어진 세그먼트 별로 크기가 다르다.  
            이를 통해 프로세스마다 필요한 만큼 공간이 할당되어 내부 단편화는 발생하지 않는다.
            
### 3. 심볼릭 링크  
윈도우의 바로가기와 동일한 기능  
- **필요** : 용량을 적게 차지하기 때문에(경로 정보만 가지고있다) 해당 파일로 접근이 필요할때 관리가 수월해진다.  
예를 들어 다른 파일 시스템의 파일이 필요한 경우, 복제를 하면 그만큼 공간을 차지하게 되는데 심볼릭 링크를 사용하면 적은 용량으로 빠르게 관련 파일에 접근할 수 있다.  
또 디렉터리와 파일간 권한을 관리하는것에도 사용할 수 있다.  

- **방법** : `chmod [사용자] [권한연산자] [권한] [option] [파일이름]`  
    - 사용자 : u(user), g(group), o(other), a(all)
    - 권한 연산자 : +, -, =
    - 권한 : rwx
    - -R : 하위파일 권한 설정
    - ex) chmod a+rx testfile1 : testfile1에 모든 사용자에 대하여 읽기,실행 권한 부여

- **하드 링크** : 모든 정보가 동일한 파일을 생성하는 바로가기 방식.  
심볼릭 링크와 달리 원본 파일과 용량이 동일하며 파일의 메타데이터를 나타내는 inode 번호도 동일하다.  
하드링크 파일은 같은 파일로 인식하기 때문에 하드링크로 생성한 파일을 수정해도 원본 파일이 변경된다.  
하드링크는 소프트링크와 달리 디렉터리는 링크로 만들 수 없다.  
트리구조인 파일 시스템 특성상 상/하위 디렉터리간 무한 참조가 발생하기 때문이다.  
파일의 하드링크 보유 여부는 ll 과 같은 명령어에서 권한과 사용자 사이에 있는 번호(하드링크 갯수)를 보고 판단할 수 있다.  

- 링크 파일 확인방법  
소프트링크는 파일 정보에서 `lrwxr-xr-x`와 같이 끝에 l 로 표시된다.  
그리고 파일 이름도 화살표와 함께 원본 파일이 함께 표시된다.  
하드 링크는 링크 갯수 정보를 통해서 하드 링크가 존재함을 알 수 있으며 해당 파일이 하드 링크 파일인지 여부는 판단할 수 없다. 똑같은 파일을 다른 이름으로 하나 더 생성하는 것과 같기 때문이다.
    - 복사와 하드링크  
    둘 다 같은 파일을 하나 더 생성한다는 것은 같지만  
    하드링크는 추가로 용량을 차지하지 않으며 하드링크 파일을 수정하면 원본 파일도 변경된다.  
    이에 반해 복사는 똑같은 용량의 파일을 하나 더 생성하는 것이며 복사된 파일을 수정해도 원본파일에는 영향이없다. inode번호 역시 달라지게된다.  

### 4. 서비스와 스케쥴링  
스케쥴링은 프로세스간 실행 순서를 설정하는 것이며 리눅스에서는 cron이 사용된다.  
시스템 운영에 필요한 작업을 지정하는 것과 사용자에 따라 지정하는 방법이 나뉜다.
- **필요** :  보안 검사나 데이터 전송, 로그 삭제와 같이 특정 주기마다 실행해야하는 작업이 있거나 많은 작업이 수행되는 시간을 피해서 실행해야하는 경우 작업량 분산의 용도로 사용된다.  
- **방법** :  사용자는 `crontab -e`명령을 사용해서 등록할 수 있고 `/etc/crontab`에 루트 권한으로 시스템 운영에 필요한 작업을 설정할 수 있다. 시간정보(분 시 일 월 요일), 사용자이름, 실행할 명령을 입력하면 해당 조건에 따라서 명령이 실행된다.  
`/etc/cron.allow or cron.deny` 두 개의 파일로 사용자를 제한할 수 있다.  
- 과정 :  부팅시 systemd(initd)가 실행되고 cron데몬이 실행된다.    
cron데몬은 crontab을 읽어서 해당 작업을 실행하고 cron 로그 파일에 실행 내용 기록한다.  

- at 스케쥴링  
atd 데몬에 의해 실행되고 작업은 큐와 /var/spool/at 디렉터리에 저장된다.  
at 명령을 통해 설정할 수 있으며 cron과 달리 지정한 시간에 한번 실행된다.  
at -l 명령을 통해 저장된 작업 목록을 확인할 수 있고  
`/var/spool/at` 디렉터리에서 작업 내용을 확인할 수 있다.  
`/etc/at.allow or at.deny` 파일을 통해 사용자를 제한할 수 있다.  

### 5. 서비스와 권한  
- **필요** : 리눅스는 여러 사용자가 함께 사용할 수 있는 다중 사용자 운영체제이다.  
따라서 사용자마다 파일 또는 디렉터리에 접근할 수 있는 권한을 적절하게 설정해야한다.  
- **방법** : chmod [사용자][연산자][권한] [옵션] [파일명]  
    - [사용자] : a(all), u(user), g(group), o(other)
    - [연산자] : +, -, =
    - [권한] : r(read) : 4 , w(write) : 2 , x(excute) : 1  
    - [옵션] : 디렉터리의 경우 `-R` 옵션으로 하위 파일/디렉터리의 권한도 모두 변경  
    - 예시  
    `chmod o-w file1` : 기타 사용자에 대하여 file1에 대한 쓰기 권한을 제거한다.  
    `chmod 707 file2` : 소유자, 기타 사용자에 대하여 file2에 대한 모든 권한을 부여한다. 그룹 사용자에게는 모든 권한을 제거한다.  
    (각 권한을 4,2,1 숫자로 나눠 숫자를 더해서 권한을 부여하고 자릿수에 따라 사용자가 나뉜다)  
- 설명 : ll과 같은 명령으로 파일 정보를 확인하면 `-rwxr-x-r-x` 와 같은 문자가 있는데 맨 앞은 파일정보를 나타내며(- : 파일, d : 디렉터리, l : 링크)  
그 뒤 9글자는 3자씩 나눠서 사용자, 그룹, 다른 사용자의 권한을 나타낸다.  

- 파일 소유권 변경  
파일, 디렉터리의 사용자, 그룹 자체를 변경하는 것  
`chown [사용자]:[그룹명] [옵션] [파일명]` - 그룹명 생략 가능  
`chgrp [그룹명] [옵션] [파일명]` - 그룹만 변경  
옵션 : 디렉터리의 경우 `-R` 옵션으로 하위 파일/디렉터리의 권한도 모두 변경  

### 6. 커널 모듈  
커널은 컴퓨터의 모든 자원을 관리하는 운영체제의 핵심이다.  
- **필요** : 리눅스는 시스템을 제어하는 기능이 모두 커널에 내장된 모놀리식 방식을 사용하는데 모놀리식의 경우 장치를 추가하거나 기능 추가가 필요하면 커널 자체를 수정해야해서 빌드 후 재부팅이 요구된다.  
커널 모듈은 시스템이 실행중인 상황에서 동적으로 기능을 추가하거나 제거할 수 있는 도구이며 이를 통해서 윈도우 처럼 장치 드라이버를 편하게 설치할 수 있다.  

- **방법** : 모듈이 로드될 때, 제거될 때 호출되는 함수를 갖춘 헤더파일이 필요하다  
```h
#include <linux/init.h> /* Needed for the macros */
#include <linux/module.h> /* Needed by all modules */
#include <linux/kernel.h> /* Needed for KERN_INFO */
 
static int __init hello_init(void) {
    printk(KERN_INFO "Example 2\n");
 
    return 0;    // not 0 is failed. -> init_module failed.
}
 
static void __exit hello_exit(void) {
    printk(KERN_INFO "Exit Example 2\n");
}
 
module_init(hello_init);
module_exit(hello_exit);
```
그리고 Makefile을 통해 커널모듈 파일(ko)을 생성하고 `insmod [커널모듈]`로 추가, `rmmod [커널모듈]`로 제거 한다.  
혹은 `modprobe`를 사용하면 의존성에 대한 정보를 추정해서 추가해준다.  

### 7. syslogd  
시스템 내의 수많은 커널 경고, 디버깅 정보, 메세지 등 수많은 로그 정보를 기록하는 데몬이다.  
- 동작 흐름 : systemd 가 실행되면서 syslogd도 실행되는데 이때 파일을 읽어서 로그 설정을 반영한다.  
- **설정 파일 및 방법** : 우분투 22.04기준 `/etc/rsyslog.d/50-default.conf`에 설정한다.  
[facility].[priority]   [action]  
`mail.err   /var/log/mail.err`
    - facility : 로그 유형 설정
        - auth : 로그인 등 사용자 인증
        - cron : cron 데몬 관련
        - daemon : 데몬 관련
        - kern : 커널 메세지
        - mail : 메일 관련
        - user : 사용자에 의한 프로세스
        - syslog : syslogd에 의한 모든 메세지
    - priority : 로그 우선순위=정도
        - debug : 디버깅 관련(최하위)
        - info : 단순 정보
        - notice : 알림
        - warning : 경고
        - err : 에러
        - crit : 치명적인 문제 발생
        - alert : 즉각적인 조치가 필요
        - emerg : 긴급한 상황(최상위)
    - action : 로그에 대한 행동 설정
        - 파일명 : 해당 파일 내용에 로그를 추가
        - @host : 지정한 호스트에 로그 전송
        - user : 지정한 사용자에게 로그 전송
- 로그 로테이션  
로그 파일은 지속적으로 쌓이기 때문에 시간이 지날수록 거대해진다.  
로그 로테이션 설정을 통해서 특정 주기로 새로운 로그 파일을 생성하거나, 보관일을 지정해서 오래 쌓이지 않도록 주기적으로 제거할 수 있다.  
    - 방법 : `/etc/logrotate.d/`아래 설정 파일을 수정  
        - hourly, daily, weekly, monthly.. : 해당 단위로 자른다.  
        - rotate [number] : [number]주간 로그 파일을 보관한다.
        - create : 로그파일을 자른 뒤 빈 로그 파일을 새로 생성한다.
        - include /etc/logrotate.d : /etc/logrotate.d에 저장된 설정 파일들을 불러들인다.  
    - 설정 예시
        ```conf
        /var/log/pcsd/*.log{
            weekly #주마다
            rotate 5 #5주마다 자른다
            missingok #로그 파일이 없어도 에러를 발생시키지 않는다.
            notifempty #로그 파일의 내용이 없을 경우 rotate하지 않는다.
            compress #압축한다
            delaycompress #최근 파일 외에는 모두 압축한다.
            copytruncate #기존 파일을 새로운 파일에 복사한 뒤 기존 파일의 내용을 삭제한다.
            create 0600 root root #rotate 되는 로그파일 권한 지정
        }
        ```

---

## Week3 - DISK 설정  
### DISK 종류  
    - HDD  
    물리적으로 회전하는 디스크를 사용하는 저장장치  
    SSD에 비해 속도가 느리지만 가격이 저렴하고 장애 복구가 비교적 쉽다.  
    물리적인 장애 발생률이 높다.  
    - SSD  
    플래시 메모리를 사용해서 HDD에 비해 속도가 빠르고 물리적인 장애에 강하다.  
    HDD보다 가격이 비싸지만 성능을 위한 투자 비용은 적다.  
    - 디스크 인터페이스  
    디스크 못지않게 성능에 영향을 끼치는 요소  
        - SATA : 기존 병렬 방식인 PATA의 단점(성능이 좋아질수록 선이 두꺼워진다)을 해결하기 위해 나온 방식이며 SATA3 기준으로 6Gbps
        - SAS : 별도의 컨트롤러가 장착된 인터페이스이며 컨트롤러가 CPU와 독립적으로 작업을 처리해서 안정적이다.
        - PCIe : CPU에서 lane을 할당받아 데이터를 주고받는 슬롯이며 pcie3.0 기준으로 sata3보다도 5배 빠르다.  

### RAID의 의미와 종류  
Redundant Array of Inexpensive/Independent Disk  
저장장치를 여러개 묶어서 고성능의 저장장치와 같은 효과를 얻을 수 있는 기법  
- **필요** : 적은 비용으로 고성능의 저장장치를 사용하는 효과를 얻을 수 있고 안정성 역시 증가시킬 수 있다.
- **종류** :  
    - RAID 0 : Striping  
    여러 디스크를 하나의 공간처럼 사용하는 방법  
    여러 디스크에 데이터를 분산저장함으로써 디스크당 부하를 줄여서 읽기/쓰기 성능을 향상시키는 방법  
    디스크를 증가시킬수록 성능이 증가하는데, 하나의 디스크만 고장나도 전체 데이터를 사용할 수 없게 된다.  
    - RAID 1 :  Mirroring  
    하나의 디스크에 있는 내용을 여러 디스크에 동시에 저장하는 방법  
    같은 데이터를 여러 디스크에 저장하기 때문에 디스크가 고장나더라도 쉽게 복구할 수 있다.  
    디스크를 증가시킬수록 안정성이 증가하는데 그만큼 비용도 증가한다.  
    - RAID 2,3,4 : Parity  
    여러 디스크에 분산 저장하면서 `데이터 복구를 위한 데이터 = 패리티`를 저장하기 위한 디스크를 따로 구성하는 방법  
    성능 향상과 함께 안정성도 증가하는 방법이다.  
    2 방식은 해밍 코드를 사용했고 3,4 방식은 보다 가벼운 홀수,짝수 패리티 방식을 사용했다.  
    3,4 방식의 차이는 저장 단위의 차이인데 3은 바이트 단위, 4는 블록(512바이트) 단위로 저장된다.  
    일반 디스크가 고장나면 복구가 가능하지만, 패리티 디스크가 고장나면 복구가 불가능해진다는 단점이 있다.
    - RAID 5 : 2,3,4방식을 보완한 현재 가장 잘 쓰이는 방식  
    패리티를 사용한다는 것은 동일하나, 패리티를 각 디스크에 분산해서 저장하는 방식  
    따라서 어떤 디스크가 고장나도 복구가 가능하며 패리티를 위한 공간도 적게 든다.  
    제대로된 구성을 위해서는 디스크가 3개 이상 필요하며 디스크 2개 이상의 고장에는 대처할 수 없다.  
    그래서 복구데이터를 하나 더 저장하는 6방식은 디스크 2개 고장에도 대처가 가능하다.  
    - RAID 10 : Mirroring + Striping  
    미러링(1) 된 디스크들에 스트라이핑(0)으로 분산저장하는 방식  
    반대로 스트라이핑한 디스크 전체를 미러링하는 01방식도 있다.  
    - RAID 51 : RAID 5 구성 전체를 미러링 하는 방식  
    - 즉 0 방식을 추가하면 성능이 향상되고, 1 방식을 추가하면 안정성이 증가한다.  
- **방법** : 하드웨어, 펌웨어, 소프트웨어 방식으로 나뉜다.
    - 하드웨어 방식 : RAID를 구성하기 위한 RAID카드라는 별도의 하드웨어를 설치해야한다.  
    해당 하드웨어가 직접 RAID를 컨트롤하기 때문에 가장 성능이 좋으며 구성 방식은 제조사마다 다르다. 일반적으로 제조사마다 구성을 위한 소프트웨어를 제공한다.  
    - 소프트웨어 방식 : 운영체제 위에서 소프트웨어로 구성하는 방식  
    CPU위의 운영체제 위에서 동작하기 때문에 좋은 성능을 기대하기는 어렵다.  
        - mdadm(multiple device administration)  
        리눅스 환경에서 소프트웨어 방식으로 RAID를 구성할 수 있는 서비스  
        `mdadm --create [구성할경로] --level=[레이드버전] --raid-devices=[장치수] [장치경로] [장치경로]...`
    - 펌웨어 방식 : 메인보드에서 기본적으로 제공하거나 칩셋을 설치하는 방식  
    OS 부팅 이전인 바이오스 단계에서 구성되어 소프트웨어 방식보다는 빠르지만  
    별도로 관리되는 하드웨어 방식보다는 느리다.  
- RAID 확인  
    - `mdadm --detail [장치명]` : 상세정보
    - `cat /proc/mdstat` : 현재 구성된 RAID 정보
### PV, VG, LV 설정 및 구성  
LVM : Logical Volumn Manager  
물리적인 디스크 공간을 논리적 공간으로 관리하는 방법  
나누어져있는 공간을 임의로 나누어 효율적인 공간관리가 가능하다.  
- **필요** : 10GB디스크를 3개 사용하는 경우, 총 용량은 30GB이지만 각 10GB를 대상으로 사용된다. 논리적 공간인 LV로 묶는 경우 실제로 30GB공간 하나를 사용하는 효과가 있으며 다시 임의의 공간으로 나누는 것도 가능해진다.  
- **용어**  
    - PV : 논리적 공간 - 물리적인 디스크를 말한다.
    - PE : LVM에서 PV를 나누거나 합치기 위해 사용하는 물리적인 공간의 최소단위(default 4mb)
    - VG : 물리적으로 존재하는 디스크를 하나로 모은 그룹
    - LV : VG를 논리적으로 나눈 공간
    - LE : LV를 만들기 위해 설정하는 논리적 최소 공간(default 4mb)
- **방법**  
    - 각 공간을 생성하는 pvcreate, vgcreate, lvcreate 명령이 존재한다.
    - vg, lv는 vgextend, lvextend 와  vgreduce, lvreduce 명령으로 확장 축소 역시 가능하다.  
    - 각 공간에 대해 remove명령도 존재하는데 LV -> VG -> PV 순으로 삭제해야한다.  
    - 예시  
    우선 디스크 파티션을 PV로 생성한다.
    `pvcreate /dev/sdb1 dev/sdc1`  
    그리고 각 PV를 VG로 묶는다.
    `vgcreate [그룹명] /dev/sdb1 /deb/sdc1`  
    VG를 나누어 LV를 생성한다.  
    `lvcreate -n [LV명] -L [용량g] [VG명]`
- 확인  
    - lvmdump
    - lvs, pvs  
- 주의할 점  
    - 물리적 공간인 PV가 고장나면 해당 공간으로 구성한 VG, LV역시 사용할 수 없게된다.  
    - 따라서 RAID 구성을 사용해서 안정성을 높히는 것이 좋고 lvm자체에서 소프트웨어 raid를 지원하기도 한다.  
    
### local mirror site 구성
### NAS 연결(NFS)

---

## Week4 - 이중화

### 1. 서비스 이중화

### 2. 데이터 이중화

### 트러블 슈팅  
- 각 노드는 온라인이 확인 되었으나 상대편 노드가 UNCLEARED offline이 뜨는 경우  
    : 호스트 이름 변경 후 reboot을 하니 제대로 적용
- 파일 시스템 리소스 구성에서 node1 서버(MASTER)에는 문제가 없으나 node2 서버에서 'no such file or directory' 라는 오류와 함께 공유가 안되는 문제  
    : node2 에 heartbeat를 설치하니 해결
- 중지한채로 다음날 실행해서 drbd상태를 확인하니  
    `block drbd0 split-brain detected but unresolved dropping connection` 오류 발생  
    승격 강등 동작은 했지만 수시로 오류 메세지가 발생하고  
    승격 강등 관련 명령이 실행되지 않는 등 문제 발생  
    : 클러스터 삭제 후 다시 생성해서 해결
    - pcs 관련 명령에서 pacemaker 실행 오류가난다.  
    : 해결  
    pcs cluster destroy --all 명령으로 클러스터를 다 박살내서그렇다.  
     pcs 인증을 하고 다시 setup한 뒤 클러스터를 실행하면 됨.
- nic추가 후 본딩 테스트시 노드 연결 오류  
    : 본딩 테스트를 진행하고나니 이전처럼 노드가 각각 오프라인이 되어있었다.  
    nic를 추가하면서 ip가 변경된 탓이었고, hosts파일을 수정하니 원래대로 돌아왔다.  
     - drbdadm status에서 role, disk 는 확인되는데  
    replication은 표시되지 않는 상황  
    : cluster 설정 파일 ip 수정해줘야함

### 발표 피드백 정리
- 기간에 비해 자료가 항상 부족하다  
: 과정과 결과, 개념설명 뿐만 아니라 트러블 슈팅이나 명령에 대한 상세 설정, 확인 등에 대한 자료도 포함되어야한다 최종 결과는 누군가에게 설명할 수 있는 참고자료여야 한다.  
곁다리 자료들도 모두 상세하게 알아볼것  

### 발표 후기
- '내용을 아는 사람들에게 발표하는 것'이 아니라 '아무것도 모르는 사람을 위해 자료를 준비하는 것' 이어야 한다.  
- '주제에 대해 정확하게 이해하고 설명하는 것'은 기본이고 파생되는 모든것에 대해 알아야한다.  

### 발표 보충
- 리소스에 대한 현재 상태, 설정 정보 확인  
`pcs resource debug-monitor [resource_name] --full`  
