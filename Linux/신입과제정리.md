# 리눅스 과제 정리
4주간 진행한 리눅스 과제를 정리한다.

### 나의 과제 수행 방법  
1. 주제를 검색해서 어디다 쓰는지, 어떻게 하는지를 찾는다.
2. 대부분 모르는 단어가 많기에 하나씩 파고들면서 과제를 이해한다.
3. 과제 방법에 대해서 어느정도 이해하고나면 직접 해본다.
4. 방법 위주로 ppt 정리를 하고 관련 핵심 기술, 개념에 대해 공부한다.

### 조언과 개선하면 좋을 것들
1. 주제와 관련된 개념, 단어를 모두 파고들어 조사해야한다.  
주제를 수행하는데 있어서 관련된 개념은 모두 알고있어야한다.  
과제 수행을 발표하는데 필요한 개념이 아니라, 주제를 설명하기 위해 등장하는 단어들에 대한 모든 개념
2. 처음부터 이해하고 해결해버리려하기보다도 과정을 찾아보고, 거기에서 나오는 모든 단어들에 대해 파해쳐야했다.  
한번에 이해하기 좋은 자료들을 찾다보니 오래걸렸고, 그 자료만으로 이해하기도 쉽지않아서 사용측면의 위주로만 조사한 것 같다.  
동작 원리에 대해서 상세하게, 거기에 쓰이는 개념들에 대해서도 상세하게
- 내가 원했던 것 : [모범자료](https://brunch.co.kr/@dreaminz/3)와 같은 친절한 자료의 존재
- 내가 해야했던 것 : 명령어 man페이지를 바탕으로 관련개념 싹다 정리,이해
---

## Week1 - 리눅스(우분투) 초기 설정
### 개요
보안 소프트웨어 엔지니어의 경우  
외부 인터넷이 연결되지 않은 상황에서 작업을 진행하는 경우가 대부분이다.  
리눅스 초기 설정과 함께 폐쇄망에서 작업을 하는 경우 필요한 설정에 대해 알아보자  

### 1. 파일 열기 개수 제한 해제
- **필요** : 리눅스는 디렉터리, 장치 등 모든 것이 파일이다.  
리눅스에는 최대 파일 오픈 개수가 설정되어있는데 해당 개수를 넘어서면 그 이상의 파일은 열리지 않는다. 즉 더 이상의 작업을 진행할 수 없다.  
따라서 최대 파일 열기 개수를 적절하게 수정함으로써 `too many open file` 오류를 방지해야한다.  

- **방법** : 
    - 오픈 파일 갯수 확인 `ulimit -a/ -Ha`
    - 시스템 전체 최대 오픈 파일 개수 확인 `cat /proc/sys/fs/file-max`  
    - 일시적인 방법 : ulimit -n/ -Hn [갯수] 로 변경 가능
    - 영구적인 방법 : `/etc/se2curity/limits.conf` 실행 후  
    <유저명> <soft/hard> <타입> <값> 형식으로 설정 후 저장 
    - 하지만 HardLimit의 경우에는 해당 명령으로는 1048576 이상으로는 설정 불가  
     - 커널의 최대 오픈 파일 수 변경  
    `/etc/sysctl.conf`에서 `fs.nr_open=5242880` 와 같이 설정하면(sysctl -p로 설정 반영) 

- 단어 설명
    - Soft Limit : 넘을 수도 있는, 경고 측면에서 사용 할 수 있는 제한
    - Hard Limit : 넘어서면 더이상 파일을 실행 시킬 수 없는 제한
    - `Too many open files` : 하드 리미트를 넘어선 파일 실행시 발생하는 메세지, var/log/messages에서 확인 가능하다.  

- 트러블 슈팅  
    - 분명 여러 자료에서는 ulimit -Hn으로 최대 오픈 파일 갯수를 수정할 수 있다고했다.  
    그런데 재원책임님이 말씀하신대로 기본적으로 설정된 갯수 이상으로는 변경할 수 없었다.  
    : 사실은 검색했을때 가장 첫번째로 나왔던 곳에서 최대 오픈 파일 갯수 제한을 해제하는 방법이 나와있었다. sysctl, 커널 등 관련 개념을 몰라서 가볍게 넘어갔던 탓이었다.  

### 2. 서버 타임존 설정
- **필요** : 리눅스를 설치하면 시간대가 UTC+0으로 설정되어있다.  
한국에서 사용하는 경우, 시간대가 한국으로 설정된 서비스와 작업을 진행할때 시간이 맞지않아 혼동이 생기거나 아예 서비스 자체가 동작하지 않을 수가 있다.  
따라서 작업하는 환경에 맞는 타임존을 설정해야한다.

- **방법** : 
    - 시간 상세 조회  
    : `timedatectl`
    - 타임존 확인  
    : `timedatectl list-timezones`
    - timedatectl을 사용한 설정 방법
    : `sudo timedatectl set-timezone Asia/Seoul`
    - 심볼릭 링크 방법  
    : `ls -l /etc/localtime`으로 확인 후 해당 파일 삭제 혹은 덮어쓰기  
    : 이후 새롭게 심볼릭 링크 파일을 생성 `sudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime`

- 단어 설명  
    - timedatectl : 시간 확인, 설정이 가능한 도구  
    기본적으로 현재 지역 시간, 협정 세계시간, 하드웨어의 시간, 타임존, 시스템 시간 동기화 여부, 타임서버 동기화 여부, 하드웨어 시간과 RTC를 동일하게 사용할 것인지에 대한 정보를 가진다.

### 3. NTP 서버 설정
- **필요** : Network Time Protocol  
앞선 타임존 설정과 마찬가지로 시간 설정은 리눅스 사용에서 매우 중요하다.  
여러 서버 장비를 사용하는 경우 장비간 시간이 동일해야하는데 NTP 서버를 동일하게 설정함으로써 네트워크를 통해 시간을 동일하게 설정할 수 있다.  

- **방법** :  
    - ntp 서비스 설치  
    : apt-get install -y ntp
    - /etc/ntp.conf 설정  
    : 기존 ntp설정을 삭제하고 설정하려는 ntp서버에 따라 값 입력  
    구글의 경우 : `server time1.google.com iburst`
    - ntp 재시작  
    `sudo service ntp reload`  
- 추가 사항  
1. NTP 서버는 일반적으로 외부 네트워크를 연결하게 된다.  
따라서 보안장비의 경우에는 함부로 외부 네트워크와 연결된 NTP 서버를 사용하기 쉽지않다.  
이에 대해서 현재 회사에서는 자체적으로 NTP 서버를 운영해서 폐쇄망의 경우에도 외부를 거치지 않고 시간을 설정할 수 있도록 하고있다고 한다.  
2. NTP서버를 연결할때 하나만 설정하지 않는다.  
구글의 경우에는 기본적으로 4개 서버를 설정할 수 있었는데 이를 통해서 동기화 중이던 서버가 고장이 나도 다른 서버에서 시간 데이터를 받아올 수 있기때문에 정확한 시간을 유지할 수 있다.  

### 4. systemd-networkd-wait-online.service 비활성
- **필요** : 위 서비스는 네트워크가 온라인 상태가 되기까지 기다리는 서비스 이다.  
네트워크 연결을 전제로 수행하는 작업의 경우에는 필요하지만 그렇지 않다면 기본 설정 시간인 120초간 다른 작업을 수행할 수 없게 된다.  
따라서 네트워크 연결이 필요없는 경우에는 비활성화 시키는 것이 좋다.  
- **방법** : `systemctl disable systemd-networkd-wait-online-service`  
- 추가 설명  
    - systemd-networkd-wait-online 서비스는 모든 링크가 구성되고나서 하나의 링크라도 인터넷이 연결되거나, 모두 실패할때 까지 기다리게 된다.  
    기본적으로 기다리는 시간은 120초로 설정되어 있다.  

### 5. 커널 자동 업데이트 비활성
- **필요** : 서비스 동작 중에 자동 업데이트가 진행되면 실행중이던 서비스는 갑자기 종료될 것이다.  
비활성화 시킴으로써 동작중인 서비스의 안정성을 가져올 수 있는데, 비활성화 함으로써 최신 업데이트를 반영하지 못하는 위험성 역시 존재하게 된다.  
따라서 자동 업데이트 비활성은 업데이트 시간을 사용자가 컨트롤 할 수 있다는 것에 의의가 있다.  
- **방법** :  
    - /etc/apt/apt.conf.d 의 10periodic, 20auto-upgrades 수정  
    ```
    # From
    APT::Periodic::Update-Package-Lists "1";
    APT::Periodic::Download-Upgradeable-Packages "0";
    APT::Periodic::AutocleanInterval "0";

    # To
    APT::Periodic::Update-Package-Lists "0";
    APT::Periodic::Download-Upgradeable-Packages "0";
    APT::Periodic::AutocleanInterval "0";
    APT::Periodic::Unattended-Upgrade "0";
    ```  
    혹은
    ```
    # From
    APT::Periodic::Update-Package-Lists "1";
    APT::Periodic::Unattended-Upgrade "1";

    # To
    APT::Periodic::Update-Package-Lists "0";
    APT::Periodic::Unattended-Upgrade "0";
    ```
    - 구성설정 파일을 순서대로 읽기 때문에 어느쪽에 설정해도 비활성화된다.  

### 로컬 리포지토리 구성  
- **필요** : 폐쇄망에서 패키지 설치, 업데이트를 할 수 있는 수단  
네트워크가 연결되어있지 않은 경우, 패키지를 설치하거나 업데이트를 할 수 있는 방법은 두가지가 있다. 하나는 USB나 CD와 같이 물리적인 저장장치를 연결하는 방법이 있고 두번째는 폐쇄망에만 네트워크를 따로 연결해서 필요한 파일을 제공하는 로컬 리포지토리를 구성하는 것이다.  
로컬 리포지토리 서버를 구성하는 것은 다음에 다루고 외부 저장장치를 마운트 하거나 리포지토리 서버를 연결해서 로컬 리포지토리를 설정하는 방법만 다룬다.
- **방법** :  
    - /etc/apt/source.list 에 리포지토리로 설정할 경로 지정  
    ex) add-apt-repository "deb file:/mnt/ubuntu/ local main"
- 추가 정보  
    - 외부 저장장치를 마운트하는 방법은 업데이트가 있을때마다 변경사항들을 일일히 반영해야한다.  
    따라서 외부 네트워크를 연결해서 파일을 미러링하는 서버를 구성하는 것이 좋다.

---

## Week2 - 리눅스 기타  

### 1. 리눅스의 종류  
리눅스는 다중 사용자와 멀티 태스킹에 적합한 운영체제인 UNIX를 본따 만든 운영체제로 오픈 소스라는 점이 특징이다. 따라서 수많은 사용자에 따라 다양한 종류가 탄생했고 그에 따른 차이가 존재한다.  

- 종류
    - 슬랙웨어 계열  
    배포판 중 가장 오래되었다는 것이 특징이다.  
    슬랙웨어는 패키지 매니저를 사용하지 않아서 사용자가 패키지 의존성 검사 등 모든 작업을 알아서 관리해야한다.  
    대표적인 슬랙웨어 계열의 운영체제는 SuSE가 있다.  
    SuSE는 독일에서 개발되어 유럽에서 많이 쓰이는 데스크탑/서버용 리눅스이다.  
    슬랙웨어에 패키지 매니저가 없다보니 zypper라는 패키지 매니저를 개발해서 사용한다.

    - 레드햇 계열  
    RedHat이라는 기업에서 제공하는 배포판이다. 대표적인 배포판으로는 RHEL이 있다. RHEL은 유료로 서비스를 제공하는데 소프트웨어에 대한 비용보다도 기술지원 측면의 비용이다.  
    그만큼 다른 배포판에 비해서 확실한 기술 지원을 받을 수 있다는 것이 특징이며 GPL(General Public License)에 따라 소스코드가 공개되어 있어서 RHEL을 그대로 따라 만든 CentOS라는 운영체제가 있다.  
    CentOS는 기업에서 안정적으로 운영하는 배포판을 무료로 사용할 수 있다는 특징이 있는데 RHEL의 변경사항에 대한 반영은 상대적으로 느릴 수 밖에 없고 기술 지원도 커뮤니티에 의존해야하다보니 RHEL보다는 안정적이지 못하다.  
    그 외에도 새로운 기술, 기능 업데이트 테스트에 사용되는 Fedora라는 운영체제가 있다.  

    - 데비안 계열  
    적극적으로 자유 소프트웨어를 추구하는 배포판이다.  
    기업이나 재단 등 적극적으로 배포를 추진하는 단체가 없고 안정성을 중시해서 다른 배포판들에 비해 업데이트 주기가 길다.  
    대표적인 파생 배포판으로는 우분투가 존재한다.
    우분투는 사용자 친화적인 사용법을 추구하기 때문에 초보자들에게 선호되는 운영체제가 되었다. 6개월에 한번씩 새로운 버전이 업데이트 되며 2년 주기로 최대 10년간 장기 지원을 보장하는 LTS 버전을 배포한다.  

- 대표적인 차이  
라이브러리, 설정 파일, 패키지 설치 방법과 관련해서 조금씩 차이가 있다.  
    - REHL계열은 yum 이라는 패키지 매니저를 사용하며  우분투는 apt라는 패키지 매니저를 사용한다.  
    대부분 동일한 기능을 제공하지만 사용법에서 조금씩 차이가 난다.  
    예를 들어 yum 에서 로컬 레포지토리를 구성하려면 .repo라는 파일을 생성해서 등록해줘야하는데 apt에ㅓ서는 sources.list 파일에 경로만 입력해주면 된다.  
또한 목적에 있어서도 추구하는 바가 다르다.  
RHEL을 사용하면 기업에서 제공하는 기술지원을 통해 본 업무에 집중할 수 있지만 안정적으로 운영할 수 있는 인적자원을 보유할 수 있는 기업은 CentOS나 우분투와 같은 대안을 고려할 수도 있다.  
그리고 해킹이나 디지털 포랜식 등 특정 기능에 특화된 리눅스 도 존재한다.   
### 2. 리소스 모니터링  
리소스 모니터링은 일반적으로 CPU, Memory, I/O, Network의 상태 변화를 지속적으로 감시하는 것을 말한다.  
CPU는 실질적인 작업을 처리하고, 메모리는 Cpu에서 처리할 데이터를 임시로 보관하며, 입출력 장치를 통해서 데이터를 보관하고 전송한다.  
리소스 모니터링은 컴퓨터에 사용되는 대표적인 장치들을 감시해서 장애를 확인하고 대비하는데 목적이 있다.  
- CPU 모니터링  
    - top, htop 명령어 사용
    - 주요 지표  
        - cpu% : cpu 사용 비율
        - load average : 수행되고 있거나 실행 가능한 상태, 혹은 입출력에 대기하고있는 상태에 있는 프로세스들의 개수를 1, 5, 15분 단위로 평균값을 낸 것  
            - 높다면 : 많은 프로세스가 실행 중이고, 실행 대기중이라는 것
            - 1분 값 < 15분 값 : 장애가 발생한지 시간이 조금 지났다
            - 1분 값 > 15분 값 : 현재 장애 발생중이다.  
            - 주의할 점 : 수행 되고 있는 프로세스와 응답 대기중인 프로세스 두가지를 함께 계산하고 있기 때문에 어느 프로세스의 비중이 큰지도 판단해야한다.  
                - vmstat 명령어에서 r,b 값을 확인하면 된다.
                    - r값이 높으면 CPU 리소스 부하
                    - b값이 높으면 입출력 부하
            - 참고 : [load average](https://brunch.co.kr/@dreaminz/1)
        - cpu 사용량 자체에 대한 모니터링보다도  
        다른 지표와 함께 정확한 원인 판단을 하는 것이 중요하다.
- Memory 모니터링  
    - free 명령어 사용[free](https://brunch.co.kr/@dreaminz/2)  
        - total : 전체 메모리
        - used : 사용중인 메모리
        - free : 사용되고 있지 않은 메모리
        - shared : 프로세스간 공유되고 있는 메모리(프로세스 혹은 스레드간 통신에서 사용)
        - buff/cache : 버퍼,캐시에 사용되고 있는 메모리
            - 캐시 : 빠른 실행을 위해서 '파일의 내용'을 미리 저장해 둔 것. 
            - 버퍼 : 미리 '파일에 대한 정보'를 저장해 둔 것
        - available : 사용되고 있지 않은 메모리(free)에 사용 중이지만 활용 가능한 메모리(buff/cache 등)를 더한 실제로 사용 가능한 메모리
            - 즉 free가 부족해도 available에 여유가 있다면 당장 메모리 부족을 걱정할 필요는 없다.
            - 메모리가 부족하면 자동으로 buff/cache를 정리하지만 직접 정리하는 방법도 있으며 최소 free 메모리를 설정하는 방법도 있다.
                - 직접 정리  
                : `echo [number] >> /proc/sys/cm/drop_caches`  
                [number]에는 비우기 단계를 설정한다.  
                    1. Page cache 비우기
                    2. dentry(inode와 관련해서 파일에 빠르게 접근할 수 있도록 돕는 데이터),Inode비우기
                    3. 모두 비우기
                - 최소 free 메모리 설정  
                `sysctl -w vm.min free kbytes=[value]`  
                설정한 최소 메모리 이하로 떨어지지 않게 buff/cache 메모리를 알아서 정리한다.
        - swap : 디스크에서 메모리로 활용하고 있는 공간  
            - 상대적으로 느린 디스크를 활용하는 만큼 메모리에 비해 많은 성능 저하를 보인다.  
            - /proc/<PID>/smaps 파일을 확인해서 프로세스별 메모리 영역 주소, swap크기를 확인할 수 있으며 이것이 번거롭다면 smem 툴을 사용해서 swap사용 현황을 파악할 수 있다.  
    - 메모리가 부족한 경우 캐시/버퍼 공간을 반환한다.  
    반환 이후에도 공간이 부족한 경우에는 swap을 사용하게 되는데 swap마저 어려운 경우에는 OOM(Out of Memory) Killer에 의해 프로세스를 강제 종료 시킨다. 
- 입출력 모니터링
- 네트워크 모니터링  
    - ifconfig 명령어 사용

- 추가 정리
    - 메모리 단편화 : 메모리의 공간이 작게 쪼개져서, 총 공간은 여유가 있지만 사용이 불가능한 상태
        - 내부 단편화 : 메모리 할당시 프로세스가 필요한 양보다 더 많은 메모리가 할당되어 그 차이만큼 발생한 단편화
        - 외부 단편화 : 메모리 할당/해제 과정에서 발생한 단편화(예를 들어 총 공간이 30인 상황에서 8을 사용하는 프로세스에 이어 16을 사용하는 프로세스가 실행되었다. 그리고 8이 종료되면 14의 공간이 사용가능하지만 앞에서 8/ 뒤에서 6의 공간이 남아 9 이상은 사용이 불가능한것)
        - 해결 방법
            1. Paging - 리눅스에서 사용중인 방법  
            공간을 동일한 크기로 분리해서 메모리를 분할하여 할당하는 방법.  
            프로세스 메모리를 연속적으로 배치하지 않아서 외부 단편화가 발생하지 않는다.  
                - 리눅스 커널은 `buddy system`을 사용해서 메모리를 할당한다.  
                메모리를 2^n으로 각각 할당해서 프로세스에서 필요한 만큼 연속된 페이지를 제공하는 방식이다.

            2. Segmentation - 프로세스를 code, data, stack등 영역별로 나눈 세그먼트를 기준으로 분할해서 할당하는 방법. 페이징과 다르게 나뉘어진 세그먼트 별로 크기가 다르다.  
            이를 통해 프로세스마다 필요한 만큼 공간이 할당되어 내부 단편화는 발생하지 않는다.
            
### 3. 심볼릭 링크  
윈도우의 바로가기와 동일한 기능  
- **필요** : 용량을 적게 차지하기 때문에(경로 정보만 가지고있다) 해당 파일로 접근이 필요할때 관리가 수월해진다.  
예를 들어 다른 파일 시스템의 파일이 필요한 경우, 복제를 하면 그만큼 공간을 차지하게 되는데 심볼릭 링크를 사용하면 적은 용량으로 빠르게 관련 파일에 접근할 수 있다.  
또 디렉터리와 파일간 권한을 관리하는것에도 사용할 수 있다.  

- **방법** : `chmod [사용자] [권한연산자] [권한] [option] [파일이름]`  
    - 사용자 : u(user), g(group), o(other), a(all)
    - 권한 연산자 : +, -, =
    - 권한 : rwx
    - -R : 하위파일 권한 설정
    - ex) chmod a+rx testfile1 : testfile1에 모든 사용자에 대하여 읽기,실행 권한 부여

- **하드 링크** : 모든 정보가 동일한 파일을 생성하는 바로가기 방식.  
심볼릭 링크와 달리 원본 파일과 용량이 동일하며 파일의 메타데이터를 나타내는 inode 번호도 동일하다.  
하드링크 파일은 같은 파일로 인식하기 때문에 하드링크로 생성한 파일을 수정해도 원본 파일이 변경된다.  
파일의 하드링크 보유 여부는 ll 과 같은 명령어에서 권한과 사용자 사이에 있는 번호(하드링크 갯수)를 보고 판단할 수 있다.  


### 4. 서비스와 스케쥴링
### 5. 서비스와 권한
### 6. 커널 모듈
### 7. syslogd

---

## Week3 - DISK 설정

---

## Week4 - 이중화

### 1. 서비스 이중화

### 2. 데이터 이중화

### 트러블 슈팅  
- 각 노드는 온라인이 확인 되었으나 상대편 노드가 UNCLEARED offline이 뜨는 경우  
    : 호스트 이름 변경 후 reboot을 하니 제대로 적용
- 파일 시스템 리소스 구성에서 node1 서버(MASTER)에는 문제가 없으나 node2 서버에서 'no such file or directory' 라는 오류와 함께 공유가 안되는 문제  
    : node2 에 heartbeat를 설치하니 해결
- 중지한채로 다음날 실행해서 drbd상태를 확인하니  
    `block drbd0 split-brain detected but unresolved dropping connection` 오류 발생  
    승격 강등 동작은 했지만 수시로 오류 메세지가 발생하고  
    승격 강등 관련 명령이 실행되지 않는 등 문제 발생  
    : 클러스터 삭제 후 다시 생성해서 해결
    - pcs 관련 명령에서 pacemaker 실행 오류가난다.  
    : 해결  
    pcs cluster destroy --all 명령으로 클러스터를 다 박살내서그렇다.  
     pcs 인증을 하고 다시 setup한 뒤 클러스터를 실행하면 됨.
- nic추가 후 본딩 테스트시 노드 연결 오류  
    : 본딩 테스트를 진행하고나니 이전처럼 노드가 각각 오프라인이 되어있었다.  
    nic를 추가하면서 ip가 변경된 탓이었고, hosts파일을 수정하니 원래대로 돌아왔다.  
     - drbdadm status에서 role, disk 는 확인되는데  
    replication은 표시되지 않는 상황  
    : cluster 설정 파일 ip 수정해줘야함

### 발표 피드백 정리
- 기간에 비해 자료가 항상 부족하다  
: 과정과 결과, 개념설명 뿐만 아니라 트러블 슈팅이나 명령에 대한 상세 설정, 확인 등에 대한 자료도 포함되어야한다 최종 결과는 누군가에게 설명할 수 있는 참고자료여야 한다.  
곁다리 자료들도 모두 상세하게 알아볼것  

### 발표 후기
- '내용을 아는 사람들에게 발표하는 것'이 아니라 '아무것도 모르는 사람을 위해 자료를 준비하는 것' 이어야 한다.  
- '주제에 대해 정확하게 이해하고 설명하는 것'은 기본이고 파생되는 모든것에 대해 알아야한다.  

### 발표 보충
- 리소스에 대한 현재 상태, 설정 정보 확인  
`pcs resource debug-monitor [resource_name] --full`  
