# 스프링 트랜잭션 전파
트랜잭션이 둘 이상 있을 때

## 커밋

- 하나의 트랜잭션(외부 트랜잭션)이 실행중인데 또 다른 트랜잭션(내부 트랜잭션)을 실행한다면  
다음으로 실행된 트랜잭션은 이 전에 실행중이었던 트랜잭션에 '참여'한다  
    - 트랜잭션 참여  
    내부 트랜잭션이 외부 트랜잭션을 그대로 이어 받아서 따른다  
    따라서 내부 트랜잭션은 새로 형성되지는 않는다.  
    즉 아무것도 안한다는 뜻이다.

- 내부 트랜잭션이 커밋되어도 끝나지 않고 외부 트랜잭션이 수행될 수 있는 이유  
    - 애초에 내부 트랜잭션을 커밋 명령을 무시한다.  
    커밋이 되면 커넥션이 종료되기 때문에 커밋 명령을 무시하고 코드를 진행한다.  
    어차피 기존에 진행중이던 트랜잭션이 있기때문이다.  

- 스프링은 이를 **물리 트랜잭션**과 **논리 트랜잭션**으로 구분한다.  
외부 트랜잭션은 실제로 커넥션을 통해서 커밋, 롤백을 수행하고,  
내부 트랜잭션은 트랜잭션 매니저를 통해 트랜잭션을 사용하는 단위로써 사용된다.  

--- 

## 롤백

- ### 1.내부 트랜잭션은 커밋했으나, 외부 트랜잭션이 롤백되는 경우  
논리 트랜잭션이 하나라도 롤백되면 전체 물리 트랜잭션이 롤백된다.

- ### 2.외부 트랜잭션은 커밋했으나, 내부 트랜잭션이 롤백되는 경우(논리 트랜잭션만 롤백된 경우)  
내부 트랜잭션을 롤백하면 물리 트랜잭션은 롤백하지 않는다.  
내부 트랜잭션이 롤백되면 트랜잭션 동기화 매니저에 롤백 전용(rollbackOnly)임을 표시한다.  
물리 트랜잭션은 커밋 이전에 롤백 전용임을 확인하고 전체 트랜잭션을 롤백한다.  

- 위 경우 스프링은 ```UnexpectedRollbackException```을 발생시킨다.  

### REQUIRES_NEW  
- 외부 트랜잭션과 내부 트랜잭션을 분리해서 사용하는 방법  
각 트랜잭션이 물리 트랜잭션을 가지게 하여 서로 영향을 주지 않게 한다.  

- 설정방법
```java
DefaultTransactionAttribute definition = new DefaultTransactionAttribute();
definition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
TransactionStatus inner = txManager.getTransaction(definition);
```

- 데이터베이스 커넥션이 동시에 2개가 사용된다.

### 기타 전파옵션
- REQUIRED - 기본  
기존 트랜잭션이 없으면 생성하고, 있으면 참여한다.  

- REQUIRED_NEW  
있든 없든 생성한다.

- SUPPORT  
기존 트랜잭션이 없으면 없는대로, 있으면 참여한다.

- NOT_SUPPORT  
있든 없든, 없이 진행한다.

- MANDATORY   
트랜잭션이 있어야한다. -> 없으면 예외발생

- NEVER  
트랜잭션이 없어야한다. -> 있으면 예외발생

- NESTED  
기존 트랜잭션이 없으면 생성하고, 있으면 중첩 트랜잭션을 만든다.
    > 중첩트랜잭션  
    외부 트랜잭션의 영향을 받지만, 외부에 영향을 주지는 않는 트랜잭션  
    중첩 트랜잭션이 롤백되어도 외부에 영향을 주지않지만, 외부 트랜잭션이 롤백되면 중첩 트랜잭션도 롤백된다.  
    
