# 첫번째 면접스터디 - JAVA
[참고자료](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Java)  
참고자료를 바탕으로 자바에 대한 면접 질문 공부해서, 금요일에 서로 발표한다.  

### JVM, GC  
- JVM : 자바가 운영체제에 구애받지 않고 재사용 할 수 있도록 자바와 운영체제 사이에서 중재자 역할을 해주며, 메모리관리를 해준다.  

- 자바프로그램의 실행과정  
    1. 자바 애플리케이션이 실행되면 JVM은 OS로 부터 프로그램에 필요한 메모리를 할당받는다.  
    2. 자바 컴파일러가 자바 소스코드를 읽어들여 자바 바이트코드로 변환시킨다.  
    3. Class Loader를 통해 클래스파일들을 JVM으로 로딩한다.  
    4. 로딩된 클래스 파일들은 Execution engine을 통해 해석된다.
    5. 해석된 바이트 코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이루어지게 된다.
    - 실행과정 속에서 JVM은 필요에 따라 메모리 관리를 수행한다.  

- Class Loader :  
클래스를 JVM내로 로드하는 역할을 한다.  
JVM내의 런타임 데이터 영역에 바이트 코드를 배치한다.
- Excution Engine :  
클래스를 실행시키는 역할.  
클래스 로더가 배치한 바이트 코드를 실행하며 바이트 코드는 두가지 방식으로 기계가 실행할 수 있는 형태로 변화한다.  
    1. 인터프리터 : 명령어 단위로 읽어서 실행하며, 한줄 씩 수행하기에 느리다.  
    2. JIT : 인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일해서 네이티브 코드로 변경하고 해당 네이티브 코드로 직접 실행하는 방식.  
    네이티브 코드는 캐시에 보관되어 여러번 실행되는 경우 유리하다.  
- Runtime Data Area :  
프로그램을 수행하기 위해 OS에서 할당받은 메모리 공간  
    - PC Register : 쓰레드 시작시 생성되며 쓰레드가 어떤 부분을 어떤 명령으로 실행해야할 지에 대한 기록을 하는 부분이다. 현재 수행중인 JVM명령의 주소를 갖는다.  
    - JVM Stack : 각종 변수나 임시 데이터, 스레드, 메서드 정보 등 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역.  
    메소드 호출마다 저장할 수 있는 공간이 생성되고, 수행이 끝나면 삭제한다.
    - Native method Stack : 자바가 아닌 다른 언어로 작성된 코드를 위한 공간.
    - Method Area(Class Area = Static area) : 클래스 정보를 처음으로 메모리에 올릴때, 초기화되는 대상을 저장하기 위한 공간이며 사실상 거의 모든 바이트 코드가 올라간다.  
- Heap Area : 객체를 저장하는 공간. new 연산자로 생성된 객체와 배열을 저장하며 세 부분으로 나눌 수 있다.  
    - Permanent Generation : 생성된 객체들의 정보의 주소값이 저장된 공간. 클래스 로더에 의해 로드된 클래스, 메서드 등에 대한 메타 정보가 저장되는 영역이며 JVM에 의해 사용된다.  
    - New/Young : 객체들이 최초로 생성되어 저장되는 공간
    - Old : New 에서 일정 시간 참조되고 있는, 살아남은 객체들이 저장되는 공간.

- Garbage Collection  
    - Eden/Survivor 0,1  
    eden은 새로 생성된 객체가 위치하는 공간이며 eden에서 gc가 발생한 뒤 살아남은 객체는 survivor 영역으로 이동된다.  
    이동된 객체가 다시 일정 횟수 이상 살아남으면 Old 영역으로 이동한다.  
    여기서 이루어지는 gc는 minor gc라고 한다.
    - Old  
    Old영역에서 이루어지는 GC는 모든 객체들을 검사한다. 시간이 오래걸리고 실행 중 GC를 실행하는 스레드 외에는 모두 작업을 멈춘다.  
    소멸시킬 대상은 힙 내의 다른 객체외에는 참조가 없는 객체이다.  

### Collection
Collection을 사용하는 이유 : 다양한 데이터를 다루는 방법이 다양하기 때문이다. 배열과 다르게 요소간 순서를 기억하고있어서 추가,수정,삭제가 용이하고 공간확보도 쉽다.  
    - List : 객체를 인덱스로 관리해서 검색,추가,삭제가 편리하다.
    - SET : 중복된 값을 허용하지 않는다. 정확하게는 key를 value로 하는 map과 같다. 수학에서 집합과 같다.
    - Map : Key-Value가 쌍으로 저장되는 구조로 이루어져있다. value는 중복이 가능하지만 key는 중복을 허용하지않는다. 순서를 유지하지않지만 LinkedHashMap과 같은 순서를 유지하는 map도 존재한다.
    - Stack,Queue

### Annotation  
인터베이스를 기반으로 한 문법. 주석과 비슷하지만 기능을 주입할 수도 있다.  
@Override 어노테이션이 JDK에 내장된 대표적인 어노테이션이고  
Lombok에서 사용하는 어노테이션과 같이 기능과 함께 만들어낼 수도 있다. 

### Generic  
특정한 타입만 사용할 수 있도록 컴파일 과정에서 타입체크를 해주는 기능.  
컴파일 과정에서 타입을 체크하기 때문에 객체의 타입 안정성을 높여준다.  

### final  
클래스에 사용된 경우 : 다른 클래스에서 상속하지 못한다.
메소드에 사용된 경우 : 다른 메소드에서 오버라이딩하지 못한다.
변수에 사용된 경우 : 상수 값이 되어 새로 할당할 수 없게 된다.  

### Overriding / Overloading

